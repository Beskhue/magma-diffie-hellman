declare type CryptoCrvEll;
declare attributes CryptoCrvEll: Curve, Generator, Order, Cofactor;

intrinsic Print(crv::CryptoCrvEll)
{Print crv}
    printf
        "Crypto-elliptic curve with %o and generator %o generating a subgroup of order %o with cofactor %o",
        crv`Curve,
        crv`Generator,
        crv`Order,
        crv`Cofactor;
end intrinsic;

intrinsic CryptoEllipticCurve(
    coef::[FldElt],
    G::FldElt,
    order::RngIntElt,
    cofactor::RngIntElt
) -> CryptoCrvEll
{Create an elliptic curve for cryptographic purposes of the form
y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6
over the field of the elements of a_x.

See `EllipticCurve` for the format of the (Weierstrass) elliptic curve
coefficients in `coef`.

With cyclic subgroup generated by G
(where G is the x-coordinate of the generator element on the curve).
Further, the order and cofactor of the cyclic subgroup must be given.
The order and cofactor can be checked using `ValidateParameters`. Cryptographic
security of the curve can be checked using `ValidateSecurity`.
}
    //K<x> := FiniteField(p);
    //c_a := a * x;
    //c_b := b * x;
    c := New(CryptoCrvEll);
    c`Curve := EllipticCurve(coef);
    c`Generator := Points(c`Curve, G)[1];
    c`Order := order;
    c`Cofactor := cofactor;
    return c;
end intrinsic;

intrinsic ValidateParameters(curve::CryptoCrvEll) -> BoolElt
{Validate the order and cofactor of the elliptic curve.}
    if Order(curve`Generator) ne curve`Order then
        return false;
    end if;
    if Order(curve`Curve) / curve`Order ne curve`Cofactor then
        return false;
    end if;
    return true;
end intrinsic;

intrinsic ValidateSecurity(curve::CryptoCrvEll) -> BoolElt
{Validate the cryptographic security of the curve using
 `ValidateCryptographicCurve`.}
    return ValidateCryptographicCurve(
        curve`Curve,
        curve`Generator,
        curve`Order,
        curve`Cofactor
    );
end intrinsic;
